{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Crocus Documentation","text":"<p>Crocus (Cross calendar unification software) is a unidirectional calendar synchronization tool. It queries events from a set of event sources and then pushes them into a set of event sinks (or calendars).</p> <p>This is the documentation on Crocus. For a guide on how to get started, see the Getting Started section of this  documentation. For an overview over the Crocus core concepts and design decisions, see the Architecture  page.</p> <p>Crocus is distributed under the terms of the MIT license.</p>"},{"location":"advanced/architecture.html","title":"Crocus Architecture","text":"<p>Crocus uses a plugin-based architecture. There is the Crocus Core, which provides an interface for Plugins. A plugin can provide one or multiple Services which extends Crocus' functionality.</p> <p>There are four different kinds of services that plugins can provide:</p> <ul> <li>Calendar Types provide a certain type of calendar (event sink).   Calendars are responsible for synchronizing events to some kind of external sink.   An example for a calendar type is Google Calendar  provided by the Google Plugin.</li> <li>Event Source Types provide a certain type of event source.   Event sources are responsible for fetching events from some kind of external source.   An example for an event source type is iCalendar provided by the iCalendar Plugin.</li> <li>Event Filter Types provide a certain type of event filter.   Event filters are responsible for filtering and modifying events after they have been retrieved from an event source.   An example for an event filter type are Simple Filters provided by the Filter Plugin.</li> <li>Attribute Providers are used to register additional attributes to store additional data on events.</li> </ul>"},{"location":"advanced/architecture.html#events","title":"Events","text":"<p>The central type object that Crocus deals with is the event. Crocus models an event in a rather simple way, using only these attributes:</p> <ul> <li>An identifier that must be unique among all events from the same event source.</li> <li>A name of the event</li> <li>An optional description of the event</li> <li>An optional location of the event</li> <li>An optional absolute URL describing the event</li> <li>Date and Time information</li> </ul> <p>Most event sources provide additional information about events, and most calendars accept additional information about  events. Crocus intentionally keeps the number of event fields to a minimum, but allows plugins to register additional  attributes that can attach extra information to events.</p> <p>Unlike many other calendar-related applications, Crocus events do not support recurrence. Recurring events are probably the feature that causes the most complexity and incompatibility issues in calendar-related  software.</p> <p>Therefore, Crocus does not support recurrence at all. Event sources that fetch events from a source supporting recurrence must expand these into individual event instances  and pass them to Crocus separately. Calendars that push events to a sink supporting recurrence may detect the expanded recurrence and collapse them back  into a single event. Consequently, Crocus cannot fully support events repeating infinitely and must cut repetition off at some point in time.</p> <p>The date and time of an event is always one of the following types:</p> <ul> <li>A start date and an end date, each consisting of a year, month and day.   Both the start and end days are part of the event.</li> <li>A start timestamp and an end timestamp, both with nanosecond precision.</li> <li>A start timestamp with nanosecond precision but no end timestamp.   In this case, the event is treated as open-ended with an unknown duration.</li> </ul> <p>Note that an event does not store time zone information in any of these cases. Time zones are a property of calendars, not events. Therefore, calendar implementations are required to convert timestamps into the appropriate local time for their event  sink.</p>"},{"location":"advanced/architecture.html#attributes","title":"Attributes","text":"<p>Attributes allow plugins to attach extra information to events. Plugins can register attributes by providing an attribute provider service.</p> <p>An attribute consists of a unique name and an optional default value, as well as a function that encodes how to  serialise and deserialise its values. The Crocus core itself provides no additional attributes. However, some of the bundled plugins do. See the plugin section for details.</p>"},{"location":"advanced/architecture.html#filters","title":"Filters","text":"<p>Event filters are added to event sources. As well as discarding events, an event filter can modify them as they pass through the filter. Multiple filters added to an event source are invoked in the order they were added.</p> <p>Event filters cannot modify the unique identifiers of events passing through them and therefore cannot turn a single  event into multiple events.</p>"},{"location":"advanced/architecture.html#service-interface","title":"Service Interface","text":"<p>This section documents, what logic event sources, filters and calendars need to provide and what logic is performed by  the Crocus core.</p>"},{"location":"advanced/architecture.html#event-source","title":"Event Source","text":"<p>Event sources only have a single function, which is fetching the underlying source and returning a list of events for  further processing by crocus. Crocus always expects an event source to return all events from the underlying source. However, if the underlying source support incremental requests, where it only sends changes that were made since the  last run, the event source service may store the retrieved events in the <code>plugin-data</code> folder and then use incremental  fetch to fetch changes and build a complete event list from these.</p> <p>The only function of event sources is to fetch the underlying source and return a list of events for further processing  by Crocus. Crocus always expects an event source to return all events from the underlying source. However, if the underlying source supports incremental requests and only sends changes made since the last run, the  event source service can make of that and store the retrieved events in the <code>plugin-data</code> folder. On the next run, it can then use incremental fetch to retrieve the changes and compile a full list of events.</p>"},{"location":"advanced/architecture.html#event-filters","title":"Event Filters","text":"<p>Event filters also only have a single function. They retrieve one event after another. For each event, they may return it unchanged, return a changed event return no event at all, in which case the event is  dropped. Filters should not keep internal state as it is not specified, in which order they will receive the events retrieved  from an event source.</p>"},{"location":"advanced/architecture.html#calendars","title":"Calendars","text":"<p>As Crocus pushes incremental updates to calendars by default, the API that calendars need to provide is more complex  than that of event sources and filters. Calendar implementations need to provide the following functionality:</p> <ul> <li>Synchronise changed events:   The calendar receives two lists: one of events that are either new or modified, and one of deleted events.   It then needs to apply these changes to the downstream event sink.</li> <li>Delete some events only if they exist:   In the event of an error or crash, Crocus stores a list of event identifiers that could exist in the calendar but are    not in a known state.   The next time Crocus runs, the calendar needs to delete all these events to return the calendar to a known state.</li> <li>Delete all events in the calendar:   This is mainly required to support the <code>--no-incremental</code> option.   In this case, Crocus has no knowledge of the calendar's state and resets it completely before pushing any events.</li> </ul> <p>Downstream calendars often use their own identifiers for events that are randomly generated by the calendar itself. Crocus handles the mapping from internal Crocus event identifiers to identifiers native to the downstream calendar. Therefore, calendar implementations must notify Crocus immediately once a new native event identifier has been assigned  to an event.</p>"},{"location":"advanced/configuration-format.html","title":"Configuration Reference","text":"<p>This page provides a detailed explanation of the system configuration file, <code>config.groovy</code>. It is an ordinary Groovy script that is executed in a specific context to generate a set of calendars and event sources. This means that all regular Groovy features can be used in the configuration file. However, in most cases, it won't be necessary to use any complex Groovy features, and the file resembles an ordinary,  expressive configuration file. Nevertheless, you have the full power of Groovy at your disposal when required.</p>"},{"location":"advanced/configuration-format.html#service-identifiers","title":"Service identifiers","text":"<p>A service identifier is a string that identifies a service type, such as a calendar type, event source type, or  event filter type. Each service type has a unique name inside the plugin that provides the service.</p> <p>A service identifier can take one of two forms:</p> <ul> <li>An unqualified service identifier is simply the name of a service.   This name must be unique across all loaded plugins.</li> <li>A qualified service identifier consists of a plugin name followed by a colon (<code>:</code>) and a service name.   This type of service identifier always uniquely references a service.</li> </ul> <p>For example, the <code>simple</code> filter from the filter plugin can be referenced as  <code>tuxtown.crocus.filter:simple</code> or, if no other event filter of name <code>simple</code> exists in another plugin, just as  <code>simple</code>.</p>"},{"location":"advanced/configuration-format.html#the-calendars-block","title":"The <code>calendars</code> block","text":"<p>The <code>calendars</code> block defines calendars that Crocus can synchronize events into. Calendars can be added like this: <pre><code>calendars {\n    add('tuxtown.crocus.google:google', 'mycalendar') {\n        // Calendar configuration\n    }\n}\n</code></pre> The first argument of the <code>add</code> function is a service identifier, the second argument is the  calendars name. The nested calendar configuration block is used for service specific configuration. See the Plugins section for details on the configuration options for different calendar types.</p> <p>There is also a shorthand syntax. If the calendar type can be expressed as an unqualified service identifier, a calendar can also be added like this: <pre><code>calendars {\n    google('mycalendar') {\n        // Calendar configuration\n    }\n}\n</code></pre> In this case, the function name is the service identifier for the calendar type.</p>"},{"location":"advanced/configuration-format.html#the-sources-block","title":"The <code>sources</code> block","text":"<p>The <code>sources</code> block defines event sources that Crocus can fetch events from. As with the <code>calendars</code> block, there are two options of adding an event source. Calendars can be added like this: <pre><code>sources {\n    add('tuxtown.crocus.ical:ical', 'mysource1') {\n        // Event source configuration\n    }\n    ical('mysource2') {\n        // Event source configuration\n    }\n}\n</code></pre> The latter approach only works for unqualified service identifiers.</p> <p>Contrary to calendars the event source specific configuration does not go directly into the nested configuration block. Instead, the following functions are defined there:</p> <ul> <li>The <code>into</code> function takes the name of a calendar as argument and specifies that events from th event source shall be    placed in that calendar.   Example:   <pre><code>add('tuxtown.crocus.ical:ical', 'mysource') {\n    into 'mycalendar'\n}\n</code></pre></li> <li>The <code>configure</code> function takes a configuration block with the configuration specific to the event source type.   See the Plugins section for details on the configuration options for different event source    types.   Example:   <pre><code>add('tuxtown.crocus.ical:ical', 'mysource') {\n    configure {\n        // Configuration options specific to the type of event source\n    }\n}\n</code></pre></li> <li>The <code>filter</code> function takes an argument that is a service identifier of an event filter and adds that filter to the    filter chain for this event source.   Example:   <pre><code>add('tuxtown.crocus.ical:ical', 'mysource') {\n    filter('tuxtown.crocus.filter:simple') {\n        // Configuration options specific to the event filter\n    }\n}\n</code></pre></li> </ul>"},{"location":"advanced/configuration-format.html#globals-secrets","title":"Globals &amp; Secrets","text":"<p>Crocus defines two more global symbols in the configuration file: The <code>secrets</code> object provides access to secrets as explained in Providing Secrets. The <code>globals</code> object holds some global utility functions, namely:</p> <ul> <li><code>globals.systemTime</code> is the current system time as a timestamp.   It does not include timezone information.</li> <li><code>globals.systemTimezone</code> is the system timezone.</li> <li><code>globals.http</code> allows to configure an HTTP resource.   It can be used like this:   <pre><code>globals.http(\"https://some.http/url\") {\n    // Additional configuration options\n}\n</code></pre>   where the *additional configuration options are</li> <li><code>header(name, value)</code> sets a header of the HTTP connection.</li> <li><code>noRedirects()</code> disabled following of HTTP redirects.</li> <li><code>authenticate(host, username, password)</code> adds HTTP basic authentication for a specific host.     This function can be called multiple times to set different authentication for different hosts.     This is especially useful, if the requested URL redirects to another host.</li> <li><code>trust(certificate)</code> trusts a certificate, where certificate can be a <code>pem</code> or <code>der</code> file in <code>X.509</code> format.     If at least one custom certificate is specified, system certificates are ignored.</li> </ul> <p>All globals can also be called without the <code>globals</code>-prefix, however the <code>globals</code> prefix exists for cases in which a  name conflicts with a variable or function declared in a lower scope.</p>"},{"location":"advanced/configuration-format.html#automatic-type-conversations","title":"Automatic type conversations","text":"<p>Crocus provides a whole range of automatic type conversations. That means, in most cases it's possible to write the value of a type such as <code>Path</code>, <code>URI</code> or <code>ZonedDateTime</code> as a  string and let Crocus auto-convert it to the required type. This greatly improves the readability of the configuration file. For an overview over the exact type conversations performed, see the  Service Configuration page.</p> <p>Crocus uses the following date format for converting strings into temporal values: <pre><code>yyyy-MM-dd[\"T\"HH:mm:ss[.nnnnnnnnn][OFFSET[\"[\"TZID\"]\"]]]\n</code></pre> Brackets mark an optional part, text between quotes (<code>\"</code>) is treated literally. <code>OFFSET</code> is <code>+HH[:MM]</code>, <code>-HH[:MM]</code>, or <code>Z</code> for <code>UTC</code>. <code>TZID</code> is a timezone identifier such as <code>Europe/London</code>. If time zone information is required but not provided, the system time zone is used.</p>"},{"location":"advanced/io-mode.html","title":"IO Mode","text":"<p>Usually, when you invoke Crocus, it performs an incremental synchronization of all calendars in the system  configuration. However, there is also another mode of operation called IO mode. In this mode, Crocus performs the following steps:</p> <ul> <li>Aggregate events from a list of event sources.</li> <li>Apply a list of event filters on these events.</li> <li>Push the events into a list of calendars.</li> </ul> <p>The sources, filters and sinks are given on the command line. Note that in IO mode, all sinks will always receive the exact same events. To push different events to different calendars, multiple runs are required.</p> <p>IO mode is activated by using the <code>--io</code> command line option. In IO mode, the available command line options differ. A table of available options can be found below.</p> <p>Option</p> <p>Description</p> <p> <code>--load &lt;file&gt;</code></p> <p>Reads the given file as json file in Crocus own event json format when aggregating events.</p> <p> <code>--dump &lt;file&gt;</code></p> <p>Dump all events into the given file in Crocus event json format. </p> <p> <code>--source &lt;name&gt;</code></p> <p>Aggregates all events retrieved from the event source of the given name in the system configuration.</p> <p> <code>--calendar &lt;name&gt;</code></p> <p>Aggregates all events that would have been placed in the calendar of the given name in the system configuration.</p> <p> <code>--sink &lt;name&gt;</code></p> <p>Pushes all events into the calendar of the given name in the system configuration. This option causes a non-incremental synchronization.</p> <p> <code>--isink &lt;name&gt;</code></p> <p>Pushes all events into the calendar of the given name in the system configuration. This option causes an incremental synchronization.</p> <p> <code>--filter &lt;filter&gt;</code></p> <p>Adds a filter to the list of filters to run on all aggregated events. The format such a filter specification is explained below.</p>"},{"location":"advanced/io-mode.html#filter-specifications","title":"Filter Specifications","text":"<p>The <code>--filter</code> option requires a filter specification as its argument. Filter specifications have the following general format <code>id=code</code>, where <code>id</code> is a service identifier as explained in the configuration reference and <code>code</code> is some groovy code to configure that filter. Filter specifications can also declare a namespace. In this case, the format is <code>id@ns=code</code>. The namespace <code>ns</code> limits which events are subject to filtering. A namespaced filter will only filter events that originated from an event source with a name equal to the filter's  namespace. Sources added with the <code>--load</code> option have no name and therefore use <code>file</code> as their namespace.</p> <p>The following list contains some examples of valid filter specifications</p> <ul> <li><code>modify=name { it += \" (filtered)\" }</code> uses the modify filter from the Filter Plugin to    append the string <code>(filtered)</code> to the name of events.</li> <li><code>tuxtown.crocus.filter:simple@file=after \"2024-01-01\"</code> uses the simple filter from the    Filter Plugin to filter out events before the start of 2024.   This filter specification uses a qualified service identifier to select the filter type.</li> <li><code>simple=</code> another example using the simple filter from the Filter Plugin.   In this case, none of the configuration methods of the filter are invoked.   Therefore, this filter effectively is a no-operation.</li> </ul> <p>Note that filter definitions often contains special characters that need to be quoted in a shell.</p>"},{"location":"advanced/io-mode.html#examples","title":"Examples","text":"<p>Here are some example of IO mode.</p> <ul> <li>Synchronise only a single calendar from the system configuration (in this case <code>mycalendar</code>).   <pre><code>crocus --io --calendar mycalendar --isink mycalendar\n</code></pre></li> <li>Read events from <code>in.json</code> and remove all events in August 2021, then write the result to <code>out.json</code>.   <pre><code>crocus --io --load in.json --filter 'simple=outside(\"2021-08-01\",\"2021-08-31\")' --dump out.json\n</code></pre></li> <li>Clear a calendar from the system configuration.   As there are no event sources defined, the list of aggregated events is empty, which will clear the calendar.   <pre><code>crocus --io --sink mycalendar\n</code></pre></li> <li>Perform an event dump for a single event source without touching any calendars.   <pre><code>crocus --io --source mysource --dump event-dump/mysource.json\n</code></pre></li> </ul>"},{"location":"advanced/sesquiannual.html","title":"Sesquiannual","text":"<p>Sesquiannual is a library for dealing with iCalendar data that extends the  Biweekly library. Its main feature is the ability to calculate when individual events take place, taking into account recurrence rules and  specific instances of repetition.</p> <p>Sesquiannual is developed alongside Crocus and is used in the iCal Plugin. However, as it may be useful on its own, it is also available as a standalone library. It is published on the tuxtown maven.</p> <p>The following example shows how to include Sesquiannual in a Gradle project.</p> build.gradle<pre><code>repositories {\n    maven { url = 'https://maven.tuxtown.eu/release' }\n}\n\ndependencies {\n    api 'eu.tuxtown.crocus:sesquiannual:&lt;version&gt;'\n}\n</code></pre> <p>xkcd/1602 - Linguistics Club</p> <p></p> <p>xkcd by Randall Munroe - https://xkcd.com</p>"},{"location":"development/bundling.html","title":"Plugin Bundling","text":"<p>Many plugins require additional libraries to operate. Therefore, plugins can bundle additional dependencies. When Crocus loads a plugin, it looks for a directory named <code>META-INF/classpath</code> inside the plugin Jar-file. Every Jar-file contained in there is loaded as a module to plugin module layer.</p> <p>The dependencies of a plugin get a changed module name at runtime to not interfere with dependencies provided by other  plugins. It is even possible that multiple plugins bundle different versions of the same library. In this case, each plugin will see its own version of the library independent of the other version that is also present  in the plugin module layer.</p> <p>Plugins can depend on other plugins to be present. Such a dependency is expressed by a <code>requires</code> directive in the plugins module descriptor.</p>"},{"location":"development/bundling.html#layer-isolation","title":"Layer Isolation","text":"<p>The standard approach of remapping module module names of bundles Jar-files is not sufficient for automatic modules. Automatic modules always read every other module and would therefore interfere with the dependencies provided by other  plugins. To circumvent this, Crocus can load all dependencies bundles with a plugin into a separate module layer that then  becomes a parent layer of the plugin layer. This has the benefit of limiting automatic modules to a single plugin. However, it also comes with a disadvantage: Dependencies bundled with that plugin can't depend on other plugins any  more.</p> <p>Layer isolation can be enabled for a plugin by setting an attribut in the plugins <code>MANIFEST.MF</code>: <pre><code>Crocus-Layer-Isolation: true\n</code></pre> In general, its advised to only enable layer isolation if there are Jar-files without an explicit module descriptor  in <code>MMETA-INF/classpath</code>. In that case it is also required to enabled layer isolation as Crocus refuses to load automatic modules without it.</p>"},{"location":"development/bundling.html#gradle-buildscript-example","title":"Gradle Buildscript Example","text":"<p>This section shows an example of a Gradle buildscript that enables dependency bundling. Dependencies that should be bundled can be added to the <code>classpath</code> configuration.</p> <pre><code>plugins {\n    'java-library'\n}\n\nvar cpDependencies = configurations.register('classpath') { cf -&gt;\n    cf.canBeResolved = false\n    cf.canBeConsumed = false\n}\nvar cpElements = configurations.register('classpathElements') { cf -&gt;\n    cf.canBeResolved = true\n    cf.canBeConsumed = false\n    cf.extendsFrom(cpDependencies.get())\n}\nconfigurations.named('implementation').configure { it.extendsFrom(cpDependencies.get()) }\n\ndependencies {\n    //classpath 'group:name:version' (1)\n}\n\ntasks.named('jar', Jar).configure {\n    // uncomment to enable layer isolation (2)\n    //manifest.attributes('Crocus-Layer-Isolation': true)\n    from(cpElements) {\n        into('META-INF/classpath')\n    }\n}\n</code></pre> <ol> <li>All dependencies added via <code>classpath</code> are bundled.    Dependencies that should not be bundled, should use <code>api</code> instead.    This for example includes the Crocus core or additional plugins that this plugin depends on.</li> <li>Uncommenting the following line adds the <code>Crocus-Layer-Isolation</code> attribute to the jar manifest and therefore enables     layer isolation.    This is required when bundling automatic modules.</li> </ol>"},{"location":"development/configuration.html","title":"Service Configuration","text":"<p>Calendar types, event source types, and event filter types often have additional configuration settings. The available configuration options are defined using the delegate configuration mechanism.</p> <p>To create a new object, Crocus first invokes the <code>createDelegate()</code> method. This method returns a delegate object. Crocus then evaluates the configuration block (a groovy <code>Closure</code>) with this object as its delegate. After that, the calendar, event source, or event filter is created by calling the <code>create()</code> method which receives the  delegate object as its argument.</p> <p>Delegate objects are usually mutable and define methods that correspond to configuration options. A sample delegate class can is found below: <pre><code>public class SampleConfig {\n\n    private Instant since = null; // (1)!\n\n    public void since(Instant since) {\n        this.since = since;\n    }\n\n    public Instant getSince() {\n        if (this.since == null) {\n            throw new NoSuchElementException(\"No start date set.\");\n        }\n        return this.since;\n    }\n}\n</code></pre></p> <ol> <li>A default value for the configuration option can be set here.</li> </ol> <p>This implements a single config property, named <code>since</code>, that takes a timestamp as an argument. It can for example be used like this: <pre><code>since '2014-11-21T17:10:00+02' // (1)!\n</code></pre></p> <ol> <li>https://www.youtube.com/watch?v=vcFBwt1nu2U&amp;t=3124s</li> </ol>"},{"location":"development/configuration.html#type-transformations","title":"Type Transformations","text":"<p>As explained in the configuration reference, Crocus  automatically converts values to required types in most cases. This section gives an overview over the available conversations. This serves as a reference to plugin authors to know, which types they can simply use for configuration values.</p> <ul> <li>All regular groovy type transformations apply.   This includes transformations from <code>Closure</code> to any functional interface.</li> <li><code>Closure</code> is converted to <code>DelegateConfiguration</code>.   This class provides an easy way to have nested configuration blocks with nested delegate objects.</li> <li><code>String</code> is converted to any enum by case insensitive match with the enum value name.</li> <li><code>String</code> is converted to <code>Attribute</code>.   Attributes are found by their unique name.</li> <li><code>String</code>, <code>Date</code>, and <code>TemporalAccessor</code> are converted to <code>Instant</code>, <code>ZonedDateTime</code>, <code>OffsetDateTime</code>,    <code>LocalDateTime</code>, or <code>LocalDate</code>.   If the resulting type has a time component and the input representation has not, the time component will be set to    midnight.   If the resulting type has a time zone and the input representation has not, the time zone will be set to the system    time zone.</li> <li><code>String</code> is converted to <code>ZoneId</code> by the time zone name.</li> <li><code>String</code> is converted to <code>TemporalAmount</code>, <code>Period</code>, or <code>Duration</code>.   The string must have a format like <code>12 days + 3 hous - 1 second</code>.</li> <li><code>String</code> is converted to <code>DayOfWeek</code>.   The string can use the three-letter abbreviation (eg. <code>tue</code>), or the full name of the day (eg. <code>thursday</code>).</li> <li><code>String</code> is converted to <code>Month</code>.   The string can use the three-letter abbreviation (eg. <code>sep</code>), or the full name of the day (eg. <code>september</code>).</li> <li><code>String</code> is converted to <code>Path</code> or <code>File</code>.   Relative path strings are resolved relative to the crocus working directory.</li> <li><code>URL</code>, <code>URI</code>, <code>Path</code>, <code>File</code>, and <code>String</code> are converted to <code>URL</code>, or <code>URI</code>.</li> <li><code>URL</code>, <code>URI</code>, <code>Path</code>, <code>File</code>, <code>String</code>, and <code>byte[]</code> are converted to <code>Resource</code>.   A resource is something that can be read as an <code>InputStream</code>.   Strings can only converted to resources if they are valid URIs or paths.</li> <li><code>String</code> is converted to <code>Charset</code> by the charset name.</li> </ul>"},{"location":"development/plugin-loading.html","title":"Plugin Loading","text":"<p>This page explains the plugin loading process and gives an introduction on how to write custom plugins.</p> <p>When Crocus starts, it loads the bundled plugins documented under in the Plugins section as well  as all plugins from the <code>plugins</code> directory in the Crocus working directory. A plugin is a regular Jar-file that is a named, non-automatic module (i.e. it provides a <code>module-info.class</code>). The module name becomes the plugin identifier. Plugins can bundle additional dependencies, see the plugin bundling page for details.</p> <p>Plugins can extend Crocus by providing services using the regular java service-loader mechanism. The relevant service interfaces are:</p> <ul> <li><code>eu.tuxtown.crocus.api.service.CalendarType</code> for calendar types</li> <li><code>eu.tuxtown.crocus.api.service.EventSourceType</code> for event source types</li> <li><code>eu.tuxtown.crocus.api.service.EventFilterType</code> for event filter types</li> <li><code>eu.tuxtown.crocus.api.service.AttributeProvider</code> for attribute providers</li> </ul> <p>Each of these service provider interfaces is explained in a relevant section below.</p>"},{"location":"development/plugin-loading.html#calendar-types","title":"Calendar Types","text":"<p>Calendar types are responsible for creating <code>Calendar</code> objects using the delegate configuration  mechanism. A calendar type must have a name that is unique among all calendar types provided by the same plugin.</p>"},{"location":"development/plugin-loading.html#event-source-types","title":"Event Source Types","text":"<p>Event source types are responsible for creating <code>EventSource</code> objects using the  delegate configuration mechanism. An event source type must have a name that is unique among all event source types provided by the same plugin.</p>"},{"location":"development/plugin-loading.html#event-filter-types","title":"Event Filter Types","text":"<p>Event filter types are responsible for creating <code>EventFilter</code> objects using the  delegate configuration mechanism. An event filter type must have a name that is unique among all event filter types provided by the same plugin.</p>"},{"location":"development/plugin-loading.html#attribute-providers","title":"Attribute Providers","text":"<p>Attribute providers define a single <code>registerAttributes</code> method that receives an attribute registry. It can then register attributes that have been created using the static <code>Attribute.create</code> methods. Attribute names must be unique among all loaded plugins.</p>"},{"location":"getting-started/configuration.html","title":"Configuring Crocus","text":"<p>The Crocus configuration file is actually a Groovy script. That means, you have the full power and flexibility of Groovy available. For example, it's easily possible to filter events based on a line of custom Groovy code directly embedded in the  configuration file.</p> <p>Crocus reads its main configuration from a file named <code>config.groovy</code>. An example configuration is provided below:</p> config.groovy<pre><code>calendars {\n    google('mycalendar') { // (1)!\n        calendarId 'your_google_calendar_id@group.calendar.google.com' // (2)!\n        auth secrets.google  // (3)!\n    }\n}\n\nsources {\n    ical('debian-releases') { // (4)!\n        into 'mycalendar' // (5)!\n        configure { // (6)!\n            source 'https://release.debian.org/release-calendar.ics' // (7)!\n        }\n        filter('simple') { // (8)!\n            after '2024-01-01' // (9)!\n        }\n    }\n}\n</code></pre> <ol> <li>Create a calendar (event sink) named <code>mycalendar</code>, that is backed by a Google calendar. The following block contains    configuration specific to Google calendar.</li> <li>Define the calendar id of the Google calendar to access.</li> <li>Define the secrets required to access the Google calendar. This makes use of the secret loading    mechanism. See the Google Plugin for information on the required secrets.</li> <li>Create an event source named <code>debian-releases</code> that retrieves events by accessing a calendar in iCalendar format.</li> <li>Specify, that events obtained from the <code>debian-releases</code> event source shall be placed in the calendar named    <code>mycalendar</code>.</li> <li>Configure the event source <code>debian-releases</code>. The following block contains configuration specific to iCalendar    sources.</li> <li>Specify the URL of the iCalendar resource.</li> <li>Add a filter of type <code>simple</code> to the event source <code>debian-releases</code>. The following block contains configuration    specific to filters of type <code>simple</code>.</li> <li>Discard events that happen entirely before the start of 2024. As the provided temporal information has no associated    timezone, the system timezone will be used to convert it to an instant.</li> </ol> <p>The above configuration creates a single calendar (event sink) named <code>mycalendar</code> that is backed by a Google calendar. The calendar uses the Secrets mechanism to load the secrets required to access the calendar. Additionally, a single event source named <code>debian-releases</code> is defined, which queries the Debian Release feed provided  in iCalendar format. Events obtained from this event source are filtered according to the filter that has been defined on the event source,  discarding events before 2024. After filtering, these events are pushed into <code>mycalendar</code></p> <p>To test the configuration file, enter the directory in which it resides and run the <code>crocus</code> command with no arguments. Further information on the accepted command line arguments and the directory structure that Crocus adheres to can be  found on the Running Crocus page.</p> <p>The configuration format is explained in detail on the configuration reference  page.</p>"},{"location":"getting-started/install.html","title":"Installing Crocus","text":"<p>The latest Crocus release can be downloaded from GitHub. It is shipped as a zip or tar.gz archive that can be unpacked at your preferred installation location. Crocus can then be executed by calling the <code>bin/crocus</code> script.</p> <p>Crocus requires at least Java 21. For Crocus to find a Java installation, either the <code>JAVA_HOME</code> environment variable must point to the location of a Java  installation or the <code>java</code> command must be found on the <code>PATH</code>. On Unix systems, its is possible to configure the java installation used by Crocus in a file named <code>conf/default</code> in the  extracted distribution like this:</p> conf/default<pre><code>JAVA_HOME=/path/to/java/installation\n</code></pre>"},{"location":"getting-started/install.html#building-from-source","title":"Building from Source","text":"<p>It is also possible to build Crocus from source: <pre><code>git clone 'https://github.com/noeppi-noeppi/Crocus.git'\ncd Crocus\n./gradlew build\n</code></pre> You'll need a suitable Java Development Kit such as  Eclipse Temurin installed. After Crocus has been built, you'll find the binary distributions in <code>core/build/distributions</code></p>"},{"location":"getting-started/run.html","title":"Running Crocus","text":"<p>Crocus can be run by calling the <code>crocus</code> start script bundled with the distribution. If invoked without any arguments, Crocus reads the configuration in the current working directory and performs an  incremental synchronization of all calendars listed in the configuration file. The behaviour can be changed by passing some of the supported options:</p> <p>Option</p> <p>Description</p> <p> <code>--help</code></p> <p>Shows a short summary of all available options. </p> <p> <code>--path &lt;path&gt;</code></p> <p>Sets the working directory, where Crocus looks for the configuration file and stores its data.</p> <p> <code>--verbose</code></p> <p>Produces more verbose output. </p> <p> <code>--io</code></p> <p>Activates IO Mode, a completely different mode of operation, described on a separate page.</p> <p> <code>--dump</code></p> <p>Writes the events of each queried event source to a json file before pushing the events into the calendars.</p> <p> <code>--no-incremental</code> </p> <p>Do not attempt to perform an incremental synchronization. Instead, delete all events from each calendar before adding new ones. This is mainly useful, if you lost the saved state from the previous run.</p>"},{"location":"getting-started/run.html#working-directory-structure","title":"Working Directory Structure","text":"<p>This section gives an overview of the files and directories Crocus creates or expects in its working directory.</p> <p>Path</p> <p>Description</p> <p> <code>config.groovy</code></p> <p>The user-provided main configuration file. See Configuring Crocus for details.</p> <p> <code>plugins/</code></p> <p>Directory for additional plugins that are loaded at runtime. </p> <p> <code>secrets.properties</code></p> <p>properties file that is read by the secret loading mechanism if it exists.</p> <p> <code>secrets/</code></p> <p>Directory, whose contents are read by the secret loading mechanism if it exists.</p> <p> <code>calendars/</code> </p> <p>Contains the last known state of all calendars defined in the system configuration in a format internal to Crocus. These files are required for incremental synchronization.</p> <p> <code>event-dump/</code></p> <p>Directory where event dumps are written to if the <code>--dump</code> command line option is given.</p> <p> <code>plugin-data/</code></p> <p>Contains data directories for plugins. The data stored here depends on the plugin.</p> <p> <code>secret-data/</code> </p> <p>Contains data directories for plugins. This directory generally stores sensitive data that should be kept secret. For example, session and refresh tokens may be stored here.</p>"},{"location":"getting-started/secrets.html","title":"Providing Secrets","text":"<p>Crocus provides a mechanism to pass secrets to services like calendars and event sources. When evaluating the system configuration, loaded secrets will be provided as properties on a global object named  <code>secrets</code>. That means a secret named <code>abc</code> can be accessed as <code>secrets.abc</code> in the system configuration.</p> <p>Crocus uses two sources to load secrets:</p> <ul> <li>If a file named <code>secrets.properties</code> exists in the Crocus working directory, it is read as a    properties-file.   Each key-value pair in the file is loaded as a secret.   The key determines the secret's name and the value determines the secret's value.</li> <li>If a directory named <code>secrets</code> exists in the Crocus working directory, Crocus loads each regular file under that    directory as a secret.   The filename becomes the secret's name and the file contents become the secret's value.</li> </ul>"},{"location":"plugins/anniversary.html","title":"The Anniversary Plugin","text":"<p>The anniversary plugin allows to define annually repeating events in a flexible DSL. Its plugin id is <code>tuxtown.crocus.anniversary</code>.</p>"},{"location":"plugins/anniversary.html#the-anniversary-event-source","title":"The <code>anniversary</code> event source","text":"<p>The anniversary event source generates annually repeating events.</p> <p>It has the following generic properties:</p> <ul> <li><code>since</code> is a local date that marks the first day of the time period in which anniversary events will be generated.</li> <li><code>until</code> is a local date that marks the last day of the time period in which anniversary events will be generated.   It defaults to the end of the year that follows the current year.</li> </ul> <p>Individual anniversaries can be created by the <code>day</code> function. It takes a name of the anniversary, then optionally a description and an anniversary date definition. The description can also be a function derived from the actual date on which the event takes place. The anniversary date definition can be given as a closure. Examples include:</p> <pre><code>day('Anniversary 1', /* anniversary date definition */)\nday('Anniversary 2', 'some description', /* anniversary date definition */)\nday('Anniversary 3', { 'it is currently ' + it.month }, /* anniversary date definition */)\nday('Anniversary 4') {\n    /* anniversary date definition */\n}\nday('Anniversary 5', 'some description') {\n    /* anniversary date definition */\n}\n</code></pre>"},{"location":"plugins/anniversary.html#anniversary-date-definitions","title":"Anniversary date definitions","text":"<p>An anniversary date definition selects a subset of days from all days that fall between the configured <code>since</code> and  <code>until</code> values. There are three ways to create an anniversary date definition:</p> <p>Function</p> <p>Description</p> <p> <code>always()</code></p> <p>Yields an anniversary date definition that selects every single day in the considered period of time.</p> <p> <code>only{ ... }</code></p> <p>Yields an anniversary date definition that evaluates the provided closure for every day in the considered period of time and select the dates for which the closure returns <code>true</code>. For example <code>only { it.dayOfMonth + it.monthValue == 7 }</code> selects all dates, where the month of day plus the month number equal seven.</p> <p> <code>on(...)</code> or  <code>in(...)</code></p> <p>Yields an anniversary date definition based on a filter. See below. Using <code>on(...)</code> is equivalent to <code>always().on(...)</code>. </p>"},{"location":"plugins/anniversary.html#anniversary-date-modifiers","title":"Anniversary date modifiers","text":"<p>There are a variety of modifier methods that can be called on an anniversary date definition.</p> <p>Function</p> <p>Description</p> <p> <code>dateDef1 &amp; dateDef2</code></p> <p>Yields a date definition that selects all dates selected by both <code>dateDef1</code> and <code>dateDef2</code>.</p> <p> <code>dateDef1 | dateDef2</code></p> <p>Yields a date definition that selects all dates selected by at least one of <code>dateDef1</code> and <code>dateDef2</code>.</p> <p> <code>dateDef + temporalAmount</code> </p> <p>Shifts all dates selected by <code>dateDef</code> by the given temporal amount into the future. The temporal amount can be given like <code>'2 years + 1 week'</code>.</p> <p> <code>dateDef - temporalAmount</code> </p> <p>Shifts all dates selected by <code>dateDef</code> by the given temporal amount into the past. This works analogous to <code>dateDef + temporalAmount</code>.</p> <p> <code>dateDef.firstDayOfMonth()</code> </p> <p>Adjusts all dates selected by <code>dateDef</code> to point to the first day of the month in which the original selected date lies. </p> <p> <code>dateDef.lastDayOfMonth()</code></p> <p>Adjusts all dates selected by <code>dateDef</code> to point to the last day of the month in which the original selected date lies.</p> <p> <code>dateDef.firstDayOfYear()</code></p> <p>Adjusts all dates selected by <code>dateDef</code> to point to the first day of the year in which the original selected date lies.</p> <p> <code>dateDef.lastDayOfYear()</code></p> <p>Adjusts all dates selected by <code>dateDef</code> to point to the last day of the year in which the original selected date lies.</p> <p> <code>dateDef.firstDayOfNextYear()</code> </p> <p>Adjusts all dates selected by <code>dateDef</code> to point to the first day of the year that follows the year in which the original selected date lies. This is equivalent to <code>dateDef.lastDayOfYear() + '1 day'</code></p> <p> <code>dateDef.next(dow)</code></p> <p>Adjusts all dates selected by <code>dateDef</code> at least zero and at most six days into the future, such that the newly selected day falls on the given day of week. A day of week can be given as a string containing its full name (<code>thursday</code>) or its three-letter abbreviation (<code>thu</code>).</p> <p> <code>dateDef.last(dow)</code></p> <p>Adjusts all dates selected by <code>dateDef</code> at least zero and at most six days into the past, such that the newly selected day falls on the given day of week.</p> <p> <code>dateDef.next(dow)</code></p> <p>Adjusts all dates selected by <code>dateDef</code> at least one and at most seven days into the future, such that the newly selected day falls on the given day of week.</p> <p> <code>dateDef.previous(dow)</code></p> <p>Adjusts all dates selected by <code>dateDef</code> at least one and at most seven days into the past, such that the newly selected day falls on the given day of week.</p> <p> <code>dateDef.firstInMonth(dow)</code> </p> <p>This is equivalent to <code>dateDef.firstDayOfMonth().next(dow)</code>.</p> <p> <code>dateDef.lastInMonth(dow)</code></p> <p>This is equivalent to <code>dateDef.lastDayOfMonth().last(dow)</code>. </p> <p> <code>dateDef.on(...)</code> or  <code>dateDef.in(...)</code></p> <p>Applies an anniversary date filter to <code>dateDef</code>. The result is a new anniversary date definition that considers all days selected by <code>dateDef</code> and only retains the days, that match the provided filter. See below.</p>"},{"location":"plugins/anniversary.html#anniversary-date-filters","title":"Anniversary date filters","text":"<p>Anniversary date filters restrict the selected events over a domain. A filter is always applied using the <code>on</code> or <code>in</code> function. Both functions behave exactly the same. All possible arguments to these functions are described in the table below:</p> <p>Filter</p> <p>Description</p> <p> <code>on(day, month)</code> </p> <p>Selects days based on the month and day of month. The day of month can be given as an integer (1-31), the month can be given as a string (<code>'september'</code> or <code>'sep'</code>).</p> <p> <code>on(day)</code></p> <p>Selects on a monthly basis based on the day of month. The day of month must be given as an integer (1-31).</p> <p> <code>on(month)</code></p> <p>Selects all days in the provided month. The month can be given as a string (<code>'september'</code> or <code>'sep'</code>).</p> <p> <code>on(dow)</code></p> <p>Select all days that fall on the provided day of the week. The day of the week can be given as a string (<code>'thursday'</code> or <code>'thu'</code>).</p> <p> <code>on(calendarWeek)</code></p> <p>Selects all days that fall in the provided calendar week. This uses ISO 8601 calendar week, where the first calendar week in a year is the week that contains the first thursday of that year. The calendar week can be given as a string of the form <code>'cw##'</code> where <code>##</code> shall be replaced by the calendar week number.</p> <p> <code>on('easter')</code></p> <p>Selects easter sundays in the gregorian calendar. </p>"},{"location":"plugins/anniversary.html#examples","title":"Examples","text":"<p>This section provides a few examples for anniversary configurations.</p> <pre><code>day('Today is a day') {\n    always()\n}\n\nday('New years eve') {\n    on(31, 'december')\n}\n\nday('This anniversary will never occur') {\n    on(31, 'february')\n}\n\nday('Friday the 13th', 'an unlucky day') {\n    on(13) &amp; on('friday') // or equivalent: on(13).on('friday')\n}\n\nday('Pentecost') {\n    on('easter') + '49 days'\n}\n\nday('Mothers Day in the US') {\n    on(1, 'may').next('sunday') + '1 week'\n}\n\nday('1. Advent Sunday') {\n    on(25, 'december').previous('sunday') - '3 weeks'\n}\n\nday('calendar week 42', 'this will be a week in mid-october') {\n    on('cw42')\n}\n</code></pre>"},{"location":"plugins/core.html","title":"The Crocus Core Plugin","text":"<p>This part of the documentation covers all builtin plugins bundled with Crocus. The Crocus core acts as a plugin itself. It is described on this page. The following pages cover the actual builtin plugins.</p> <p>The plugin id of the Crocus core is <code>tuxtown.crocus.core</code>.</p>"},{"location":"plugins/core.html#the-dump-event-source","title":"The <code>dump</code> event source","text":"<p>The <code>dump</code> event source allows loading events from a Crocus event dump as generated with the  <code>--dump</code> option. It has the following properties:</p> <ul> <li><code>source</code> is a <code>Resource</code> from where the event dump shall be loaded.</li> <li><code>charset</code> defines the character encoding in which the event dump is encoded.</li> </ul>"},{"location":"plugins/filter.html","title":"The Filter Plugin","text":"<p>The filter plugin defines some basic event filters. Its plugin id is <code>tuxtown.crocus.filter</code>.</p>"},{"location":"plugins/filter.html#the-simple-event-filter","title":"The <code>simple</code> event filter","text":"<p>This event filter provides simple filtering logic based on filter rules. In the filter config, multiple filter rules can be given. For an event to be kept, all filter rules must match. Available filter rules are:</p> <ul> <li><code>when</code>: Takes a <code>Closure</code> that configures another <code>simple</code> filter.   Only events that match the when-filter are considered for further filtering, events that don't match the when    filter are always kept.</li> <li><code>name</code>: Takes a string predicate that tests against the name of the event.</li> <li><code>description</code>: Takes a string predicate that tests against the description of the event.</li> <li><code>location</code>: Takes a string predicate that tests against the location of the event.</li> <li><code>url</code>: Takes a <code>URI</code> predicate that tests against the url of the event.</li> <li><code>before</code>: Takes a timestamp and only keeps events before that timestamp.</li> <li><code>after</code>: Takes a timestamp and only keeps events after that timestamp.</li> <li><code>during</code>: Takes two local dates and only keeps events between these.   Both dates are inclusive in the date range.   If multiple during clauses are given, they are ORed.</li> <li><code>outside</code>: Takes two local dates and only keeps events not between these.   Both dates are inclusive in the date range.</li> <li><code>timezone</code>: A timezone that is used to compare all-day events against timestamps.   If none is set, the system timezone is used.</li> <li><code>attribute</code>: Takes an attribute and a predicate on the attributes value.   The predicate must match on the attribute value for an event to be kept.   If the event does not have the attribute, the predicate must match on <code>null</code>.</li> <li><code>event</code>: Takes a predicate on the entire event object and matches on that.</li> </ul> <p>Example: <pre><code>after '2024-11-30'\nname { !it.contains('test') }\nattribute('ical_url') { it != null }\n</code></pre></p>"},{"location":"plugins/filter.html#the-modify-event-filter","title":"The <code>modify</code> event filter","text":"<p>This event filter allows to modify event properties. In the filter config, multiple event modification rules can be given. Available rules are:</p> <ul> <li><code>when</code>: Takes a <code>Closure</code> that configures a <code>simple</code> filter.   Only events that match the when-filter are considered for modification.</li> <li><code>name</code>: Takes a unary operator that operates on event names.</li> <li><code>description</code>: Takes a unary operator that operates on event descriptions.</li> <li><code>location</code>: Takes a unary operator that operates on event locations.</li> <li><code>url</code>: Takes a unary operator that operates on event urls.</li> </ul> <p>Example: <pre><code>when {\n    attribute('ical_status') { it == 'TENTATIVE' }\n}\nname { '(tentative) ' + it }\n</code></pre></p>"},{"location":"plugins/frab.html","title":"The Frab Plugin","text":"<p>The frab plugin allows loading conference schedules from Frab-compatible  XML schedule files. Its plugin id is <code>tuxtown.crocus.frab</code>.</p>"},{"location":"plugins/frab.html#attributes-provided-by-the-frab-plugin","title":"Attributes provided by the frab plugin","text":"<ul> <li><code>frab_room</code>: A string containing the conference room in which the event takes place.</li> <li><code>frab_type</code>: The type string associated with a frab event.</li> <li><code>frab_people</code>: A list of people holding a frab event.</li> </ul>"},{"location":"plugins/frab.html#the-frab-event-source","title":"The <code>frab</code> event source","text":"<p>The <code>frab</code> event source allows loading events from a Frab-compatible XML schedule. It has the following properties:</p> <ul> <li><code>source</code> is a <code>Resource</code> from where the XML schedule shall be loaded.</li> <li><code>timezone</code> is the default time zone if the schedule does not define timestamps and does not set a local timezone.   It defaults to the system timezone.</li> <li><code>charset</code> defines the character encoding in which the XML schedule is encoded.   The default is UTF-8.</li> </ul>"},{"location":"plugins/google.html","title":"The Google Plugin","text":"<p>The google plugin enabled Crocus to interface with various Google services. Its plugin id is <code>tuxtown.crocus.google</code>.</p>"},{"location":"plugins/google.html#attributes-provided-by-the-google-plugin","title":"Attributes provided by the google plugin","text":"<ul> <li><code>google_timezone_override</code>: Specifies a timezone.   If present, that timezone will be used for the event instead of the calendars default timezone.</li> <li><code>google_blocks_time</code>: Sets whether the event blocks time on the google calendar (default: <code>false</code>).</li> </ul>"},{"location":"plugins/google.html#the-google-calendar-type","title":"The <code>google</code> calendar type","text":"<p>The <code>google</code> calendar type allows pushing events into a Google calendar. It has the following properties:</p> <ul> <li><code>calendarId</code>: The id of the google calendar to access.   Exactly one of <code>calendarId</code> and <code>birthdayCalendarId</code> must be set.</li> <li><code>birthdayCalendarId</code>: The id of a personal google calendar.   This instructs Crocus to access the birthday calendar associated with that personal calendar.   Exactly one of <code>calendarId</code> and <code>birthdayCalendarId</code> must be set.</li> <li><code>auth</code>: An OAuth client secret to access the Google services.</li> </ul>"},{"location":"plugins/google.html#a-note-on-birthday-calendars","title":"A note on birthday calendars","text":"<p>Every personal calendar has an associated birthday calendars. Group calendars don't have birthday calendars. Due to restriction on Google birthday calendars, birthday calendars can only include annually repeating events. Therefore, any event that is pushed into a birthday calendar automatically gets an annual repetition.</p>"},{"location":"plugins/google.html#the-people-event-source","title":"The <code>people</code> event source","text":"<p>The <code>people</code> event source allows to load peoples birthdays from your Google contacts. It has the following properties:</p> <ul> <li><code>format</code>: Takes a unary operator on Strings that takes a persons name and returns an event name.   Alternatively, you can provide a format string such as <code>Birthday of %s</code>.</li> <li><code>auth</code>: An OAuth client secret to access the Google services.</li> </ul>"},{"location":"plugins/ical.html","title":"The iCalendar Plugin","text":"<p>The iCalendar plugin allows loading events from iCal calendars. Its plugin id is <code>tuxtown.crocus.ical</code>.</p>"},{"location":"plugins/ical.html#attributes-provided-by-the-icalendar-plugin","title":"Attributes provided by the iCalendar plugin","text":"<ul> <li><code>ical_priority</code>: The value of the <code>PRIORITY</code> property or <code>0</code> if not present.</li> <li><code>ical_status</code>: The value of the <code>STATUS</code> property if present.</li> <li><code>ical_color</code>: The value of the <code>COLOR</code> property if present.</li> <li><code>ical_classification</code>: The value of the <code>CLASSIFICATION</code> property if present.</li> </ul>"},{"location":"plugins/ical.html#the-ical-event-source","title":"The <code>\u00eccal</code> event source","text":"<p>The ical event source loads events from an iCalendar resource. As iCalendar supports recurring events and Crocus does not, recurring events are converted to a series of non-recurring  events. It has the following properties:</p> <ul> <li><code>source</code> is a <code>Resource</code> from where the iCal calendar shall be loaded.</li> <li><code>timezone</code> is the default time zone if the iCalendar does not define time zone information.   It defaults to the system timezone.</li> <li><code>charset</code> defines the character encoding in which the XML schedule is encoded.   The default is UTF-8.</li> <li><code>repeatFor</code> is a temporal amount (such as <code>'2 years'</code>) that defines, for how long event repetitions should be    created, measured from the start of the first event occurrence.   Crocus calculated two timespans for event repetition, one using <code>repeatFor</code> and another one using <code>repeatFromNow</code>.   The longer timespan will be used to calculate event repetitions.</li> <li><code>repeatFromNow</code> is a temporal amount (such as <code>'2 years'</code>) that defines, for how long event repetitions should at    least be created, measured from now on.   Crocus calculated two timespans for event repetition, one using <code>repeatFor</code> and another one using <code>repeatFromNow</code>.   The longer timespan will be used to calculate event repetitions.</li> <li><code>sequences</code> defines how to treat <code>SEQUENCE</code> numbers in iCal events.   See below for further information.</li> </ul>"},{"location":"plugins/ical.html#sequence-behaviour","title":"Sequence behaviour","text":"<p>Many iCal implementations implement the behaviour of <code>SEQUENCE</code> number in a different way the iCalendar standard  mandates. Therefore, Crocus provides four strategies for treating <code>SEQUENCE</code> numbers:</p> <ul> <li><code>uniform</code>:   Requires all events in an event group to have the same sequence number.   If that is not the case, the Crocus synchronization fails.   This fails for some iCalendar data that is valid according to the standard.   However, it helps to detect issues with iCal implementations that don't follow the standard.   This is the default behaviour in Crocus.</li> <li><code>obsolete</code>:   Higher sequence numbers obsolete lower sequence numbers.   Sequence numbers are treated globally on a whole event group.   This is the behaviour according to the iCalendar standard.</li> <li><code>isolate</code>:   Higher sequence numbers obsolete lower sequence numbers.   Sequence numbers are treated locally per repetition instance.</li> <li><code>coexist</code>:   Sequence numbers are ignored entirely.   Every event is used, even if multiple events mark the same repetition instance.</li> </ul>"}]}